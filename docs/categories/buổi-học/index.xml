<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Buổi Học on Blog Lập Trình Mạng</title>
    <link>https://TrungNguyenZzZ.github.io/Blog_Myself/categories/bu%E1%BB%95i-h%E1%BB%8Dc/</link>
    <description>Recent content in Buổi Học on Blog Lập Trình Mạng</description>
    <generator>Hugo</generator>
    <language>vi-vn</language>
    <lastBuildDate>Mon, 30 Dec 2024 09:00:00 +0700</lastBuildDate>
    <atom:link href="https://TrungNguyenZzZ.github.io/Blog_Myself/categories/bu%E1%BB%95i-h%E1%BB%8Dc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Buổi 9 (30/12) – Tổng kết khóa học</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-9-tong-ket-khoa-hoc/</link>
      <pubDate>Mon, 30 Dec 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-9-tong-ket-khoa-hoc/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Hệ thống lại toàn bộ kiến thức từ TCP/IP đến Multicast &amp;amp; RMI.&lt;/li&gt;&#xA;&lt;li&gt;Tự đánh giá điểm mạnh/yếu trong quá trình làm lab.&lt;/li&gt;&#xA;&lt;li&gt;Hoàn thiện báo cáo và chuẩn bị bài nộp cuối kỳ.&lt;/li&gt;&#xA;&lt;li&gt;Xác định hướng ứng dụng kiến thức vào dự án thực tế.&lt;/li&gt;&#xA;&lt;li&gt;Lập kế hoạch ôn tập cho các môn liên quan (Hệ điều hành, An toàn mạng).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Chuỗi kiến thức lõi: TCP/UDP → Socket → Đa luồng → Multicast/RMI.&lt;/li&gt;&#xA;&lt;li&gt;Quy trình làm bài lab: phân tích yêu cầu → chọn giao thức → thiết kế message → test.&lt;/li&gt;&#xA;&lt;li&gt;Lỗi thường gặp: timeout, dính gói, race condition, không đóng socket.&lt;/li&gt;&#xA;&lt;li&gt;Kỹ năng báo cáo: sơ đồ kiến trúc, mô tả protocol, log kiểm thử.&lt;/li&gt;&#xA;&lt;li&gt;Tiêu chí đánh giá: độ ổn định, tính đúng đắn, khả năng mở rộng.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Nhìn lại toàn khóa, phần khó nhất với mình là thiết kế giao thức đủ rõ ràng để client/server hiểu nhau trong mọi trường hợp (mất gói, trễ, hoặc client ngắt giữa chừng). Nhờ các buổi lab, mình hiểu được tầm quan trọng của format message, cơ chế timeout và log lỗi.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 8 (23/12) – Multicast UDP &amp; Java RMI</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-8-multicast-udp-va-java-rmi/</link>
      <pubDate>Mon, 23 Dec 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-8-multicast-udp-va-java-rmi/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Gửi thông báo tới nhiều client cùng nhóm multicast.&lt;/li&gt;&#xA;&lt;li&gt;Hiểu kiến trúc Java RMI và cách tạo interface dịch vụ.&lt;/li&gt;&#xA;&lt;li&gt;Thiết lập registry và kết nối client gọi hàm từ xa.&lt;/li&gt;&#xA;&lt;li&gt;Tổng hợp kiến thức TCP/UDP vào báo cáo cuối kỳ.&lt;/li&gt;&#xA;&lt;li&gt;Đánh giá ưu/nhược khi dùng Multicast và RMI.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Dải địa chỉ multicast (224.0.0.0–239.255.255.255) và quy trình join/leave group.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;MulticastSocket&lt;/code&gt; dùng chung port, các client cùng group sẽ nhận được bản tin.&lt;/li&gt;&#xA;&lt;li&gt;Thiết lập TTL để giới hạn phạm vi gói multicast.&lt;/li&gt;&#xA;&lt;li&gt;Thành phần RMI: &lt;code&gt;Remote&lt;/code&gt; interface, implementation, registry, client.&lt;/li&gt;&#xA;&lt;li&gt;RMI sử dụng serialization, mọi tham số trả về phải &lt;code&gt;Serializable&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Multicast phù hợp khi cần gửi thông báo cho nhiều client cùng lúc (ví dụ thông báo lịch học, trạng thái lớp lab). So với gửi unicast từng client, multicast tiết kiệm băng thông hơn. Tuy nhiên, multicast phụ thuộc vào cấu hình mạng và có thể bị chặn bởi router hoặc firewall.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 7 (16/12) – Đa tuyến và xử lý đồng thời</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-7-da-tuyen-va-xu-ly-dong-thoi/</link>
      <pubDate>Mon, 16 Dec 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-7-da-tuyen-va-xu-ly-dong-thoi/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lựa chọn mô hình thread phù hợp (per-connection hoặc thread-pool).&lt;/li&gt;&#xA;&lt;li&gt;Ngăn chặn race condition khi chia sẻ tài nguyên chung.&lt;/li&gt;&#xA;&lt;li&gt;Theo dõi số lượng client đang kết nối theo thời gian thực.&lt;/li&gt;&#xA;&lt;li&gt;Tối ưu throughput mà không làm cạn tài nguyên hệ thống.&lt;/li&gt;&#xA;&lt;li&gt;Biết cách dừng server an toàn khi kết thúc bài lab.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;ExecutorService&lt;/code&gt; và pattern submit task cho từng client.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;/&lt;code&gt;AtomicInteger&lt;/code&gt; để chia sẻ dữ liệu an toàn.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt;/&lt;code&gt;Lock&lt;/code&gt; khi cần bảo vệ vùng dữ liệu quan trọng.&lt;/li&gt;&#xA;&lt;li&gt;Chi phí tạo thread và lợi ích của thread pool cố định.&lt;/li&gt;&#xA;&lt;li&gt;Quy trình đóng socket trong &lt;code&gt;try/finally&lt;/code&gt; để tránh rò rỉ.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Thread-per-connection dễ hiểu nhưng có nguy cơ tạo quá nhiều thread khi client tăng đột biến, dẫn đến quá tải CPU và RAM. Vì vậy, nhóm mình chuyển sang thread pool để giới hạn số luồng xử lý đồng thời. Điều này giúp server ổn định hơn khi có nhiều client kết nối cùng lúc.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 6 (09/12) – Lập trình socket UDP</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-6-lap-trinh-socket-udp/</link>
      <pubDate>Mon, 09 Dec 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-6-lap-trinh-socket-udp/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Tạo UDP server và client trao đổi datagram ngắn.&lt;/li&gt;&#xA;&lt;li&gt;Thiết lập timeout để không bị treo khi mất gói.&lt;/li&gt;&#xA;&lt;li&gt;Cài đặt cơ chế ACK/Retry đơn giản cho thông điệp quan trọng.&lt;/li&gt;&#xA;&lt;li&gt;Quản lý kích thước gói để tránh phân mảnh.&lt;/li&gt;&#xA;&lt;li&gt;Đánh giá ưu/nhược của UDP so với TCP trong bài lab.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;DatagramSocket&lt;/code&gt;, &lt;code&gt;DatagramPacket&lt;/code&gt; và cách tái sử dụng buffer.&lt;/li&gt;&#xA;&lt;li&gt;UDP giữ nguyên ranh giới message (message boundary) nhưng không đảm bảo thứ tự.&lt;/li&gt;&#xA;&lt;li&gt;Kích thước gói an toàn ~1400 bytes để tránh phân mảnh trong mạng LAN.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;setSoTimeout()&lt;/code&gt; và cơ chế gửi lại khi không nhận được ACK.&lt;/li&gt;&#xA;&lt;li&gt;Cách nhận biết client bằng cặp địa chỉ IP + port.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Điểm khó nhất là UDP không có kết nối cố định, nên server phải tự quản lý trạng thái dựa trên IP/port gửi đến. Nếu client đổi port, server coi như một phiên mới. Ngoài ra, gói tin có thể mất hoặc đến trễ, vì vậy cần có số thứ tự (sequence) và ACK để đảm bảo dữ liệu quan trọng.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 5 (02/12) – Lập trình sockets TCP</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-5-lap-trinh-socket-tcp/</link>
      <pubDate>Mon, 02 Dec 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-5-lap-trinh-socket-tcp/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Viết server TCP có khả năng phục vụ nhiều client tuần tự hoặc song song.&lt;/li&gt;&#xA;&lt;li&gt;Thiết kế giao thức dạng text gồm phần lệnh và dữ liệu.&lt;/li&gt;&#xA;&lt;li&gt;Quản lý vòng đời kết nối: mở, xử lý, đóng an toàn.&lt;/li&gt;&#xA;&lt;li&gt;Ghi log kết nối để dễ debug và báo cáo.&lt;/li&gt;&#xA;&lt;li&gt;Nhận biết các lỗi phổ biến: treo kết nối, timeout, client ngắt giữa chừng.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Quy trình &lt;code&gt;ServerSocket.accept()&lt;/code&gt; và &lt;code&gt;Socket&lt;/code&gt; phía client.&lt;/li&gt;&#xA;&lt;li&gt;TCP là stream nên cần quy ước tách message (newline hoặc length-prefix).&lt;/li&gt;&#xA;&lt;li&gt;Đóng kết nối đúng thứ tự để tránh rò rỉ tài nguyên.&lt;/li&gt;&#xA;&lt;li&gt;Chiến lược xử lý nhiều client: tuần tự, đa luồng, thread pool.&lt;/li&gt;&#xA;&lt;li&gt;Thiết lập timeout bằng &lt;code&gt;setSoTimeout()&lt;/code&gt; để tránh treo vô hạn.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Mình bắt đầu bằng server echo cơ bản, sau đó chuyển sang giao thức text: &lt;code&gt;COMMAND|DATA&lt;/code&gt;. Quy ước này giúp server phân tách lệnh rõ ràng, ví dụ &lt;code&gt;PING&lt;/code&gt;, &lt;code&gt;TIME&lt;/code&gt;, &lt;code&gt;QUIT&lt;/code&gt;. Khi chưa có quy ước, client gửi chuỗi bất kỳ khiến server khó xử lý và dễ lỗi.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 4 (29/11) – Quản lý địa chỉ kết nối mạng</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-4-quan-ly-dia-chi-ket-noi/</link>
      <pubDate>Fri, 29 Nov 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-4-quan-ly-dia-chi-ket-noi/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Tra cứu IP cục bộ, loopback và địa chỉ site-local bằng Java.&lt;/li&gt;&#xA;&lt;li&gt;Hiểu cách hệ điều hành lựa chọn cổng nguồn khi mở socket.&lt;/li&gt;&#xA;&lt;li&gt;Phân biệt 0.0.0.0, 127.0.0.1 và IP LAN khi bind server.&lt;/li&gt;&#xA;&lt;li&gt;Nắm quy tắc đặt port cho dịch vụ sinh viên tự triển khai.&lt;/li&gt;&#xA;&lt;li&gt;Biết các bước kiểm tra xung đột port và quyền truy cập.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;InetAddress&lt;/code&gt;, &lt;code&gt;InetSocketAddress&lt;/code&gt; và &lt;code&gt;NetworkInterface&lt;/code&gt; để thao tác IP/port.&lt;/li&gt;&#xA;&lt;li&gt;Bind server vào địa chỉ cụ thể hoặc lắng nghe mọi interface (0.0.0.0).&lt;/li&gt;&#xA;&lt;li&gt;Dải port: well-known (0–1023), registered (1024–49151), dynamic (49152–65535).&lt;/li&gt;&#xA;&lt;li&gt;Khác biệt IPv4/IPv6 và cách Java xử lý song song hai loại địa chỉ.&lt;/li&gt;&#xA;&lt;li&gt;Ảnh hưởng của NAT/firewall khi client ở ngoài mạng LAN.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Khi có nhiều card mạng (Wi-Fi, Ethernet, VM), việc bind sai IP khiến client không kết nối được. Mình đã gặp trường hợp server chỉ bind vào 127.0.0.1 nên client trong LAN không truy cập được. Sau khi đổi sang IP LAN (192.168.x.x) thì mọi thứ chạy ổn.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 3 (25/11) – Quản lý các luồng nhập xuất</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-3-quan-ly-luong-nhap-xuat/</link>
      <pubDate>Mon, 25 Nov 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-3-quan-ly-luong-nhap-xuat/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Phân biệt stream nhị phân và stream ký tự trong Java.&lt;/li&gt;&#xA;&lt;li&gt;Hiểu cách bọc buffer để tăng hiệu năng đọc/ghi socket.&lt;/li&gt;&#xA;&lt;li&gt;Chuẩn hóa định dạng thông điệp để tránh dính gói/đứt gói.&lt;/li&gt;&#xA;&lt;li&gt;Biết sử dụng &lt;code&gt;try-with-resources&lt;/code&gt; và &lt;code&gt;flush()&lt;/code&gt; đúng thời điểm.&lt;/li&gt;&#xA;&lt;li&gt;Kiểm soát encoding (UTF-8) để tránh lỗi ký tự khi truyền dữ liệu.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;InputStream&lt;/code&gt;/&lt;code&gt;OutputStream&lt;/code&gt; làm việc với byte, &lt;code&gt;Reader&lt;/code&gt;/&lt;code&gt;Writer&lt;/code&gt; làm việc với ký tự.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;BufferedInputStream&lt;/code&gt;/&lt;code&gt;BufferedOutputStream&lt;/code&gt; và &lt;code&gt;BufferedReader&lt;/code&gt;/&lt;code&gt;BufferedWriter&lt;/code&gt; giúp giảm số lần IO.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DataInputStream&lt;/code&gt;/&lt;code&gt;DataOutputStream&lt;/code&gt; hỗ trợ kiểu dữ liệu nguyên thủy và length-prefix.&lt;/li&gt;&#xA;&lt;li&gt;Hàm &lt;code&gt;read()&lt;/code&gt; có thể trả về ít byte hơn yêu cầu; cần vòng lặp đọc đầy đủ.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;PrintWriter&lt;/code&gt; có autoFlush khi ghi newline, cần cấu hình đúng để không bị trễ.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Trong lập trình mạng, dữ liệu đi theo từng gói nên việc đọc/ghi thường không trọn vẹn ở một lần gọi. Nếu không xử lý đúng, client sẽ nhận thiếu dữ liệu hoặc ghép sai message. Vì vậy, việc định nghĩa khung (framing) là bắt buộc: có thể dùng delimiter (&lt;code&gt;\n&lt;/code&gt;), length-prefix (đọc trước độ dài), hoặc fixed-size.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 2 (18/11) – Kiến thức nền tảng</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-2-kien-thuc-nen-tang/</link>
      <pubDate>Mon, 18 Nov 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-2-kien-thuc-nen-tang/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Ghi nhớ mối liên hệ giữa OSI 7 lớp và TCP/IP 4 lớp để định vị lỗi nhanh.&lt;/li&gt;&#xA;&lt;li&gt;Nhận biết khi nào nên chọn TCP hay UDP dựa trên độ tin cậy và độ trễ.&lt;/li&gt;&#xA;&lt;li&gt;Hiểu vai trò của IP, port và socket trong một kết nối mạng.&lt;/li&gt;&#xA;&lt;li&gt;Nắm quy trình bắt tay TCP và cơ chế đóng kết nối an toàn.&lt;/li&gt;&#xA;&lt;li&gt;Biết các tham số cơ bản khi khởi tạo socket (timeout, backlog, buffer).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Ánh xạ tầng OSI sang TCP/IP: Application ↔ (Application), Transport ↔ (TCP/UDP), Internet ↔ (IP), Link ↔ (Ethernet/Wi-Fi).&lt;/li&gt;&#xA;&lt;li&gt;TCP header và ý nghĩa các trường: Source/Dest port, Sequence, ACK, Window, Flags (SYN/ACK/FIN).&lt;/li&gt;&#xA;&lt;li&gt;UDP header tối giản (Source/Dest port, Length, Checksum) và đặc tính không đảm bảo.&lt;/li&gt;&#xA;&lt;li&gt;Vòng đời kết nối TCP: DNS → connect → 3-way handshake → truyền dữ liệu → FIN/ACK → TIME_WAIT.&lt;/li&gt;&#xA;&lt;li&gt;Công cụ quan sát kết nối: &lt;code&gt;netstat&lt;/code&gt;/&lt;code&gt;ss&lt;/code&gt; để xem trạng thái port, Wireshark để bắt gói.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Khi ghép OSI với TCP/IP, mình dễ dàng xác định lớp nào đang gặp vấn đề. Ví dụ lỗi ở tầng Application thường xuất hiện dưới dạng sai định dạng dữ liệu, còn lỗi ở tầng Transport liên quan đến timeout hoặc mất gói. Cách suy nghĩ theo lớp giúp mình viết báo cáo có cấu trúc hơn và giải thích được nguyên nhân.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 1 (11/11) – Tổng quan khóa học</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-1-tong-quan-khoa-hoc/</link>
      <pubDate>Mon, 11 Nov 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-1-tong-quan-khoa-hoc/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Hiểu kỳ vọng của giảng viên về báo cáo và minh chứng lab.&lt;/li&gt;&#xA;&lt;li&gt;Cài đặt đầy đủ JDK, IDE và công cụ kiểm tra mạng.&lt;/li&gt;&#xA;&lt;li&gt;Phác họa các chủ đề chính sẽ học trong 8 tuần tới.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Tóm tắt mô hình TCP/IP và vai trò của từng tầng.&lt;/li&gt;&#xA;&lt;li&gt;Lộ trình bài lab: từ Socket cơ bản tới Multicast &amp;amp; RMI.&lt;/li&gt;&#xA;&lt;li&gt;Nguyên tắc viết báo cáo: trình bày lý thuyết, sơ đồ, mã nguồn và kết quả kiểm thử.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Ngoài các nội dung trên, giảng viên nhấn mạnh quy trình làm bài:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
