<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nhật ký Lập Trình Mạng on Blog Lập Trình Mạng</title>
    <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/</link>
    <description>Recent content in Nhật ký Lập Trình Mạng on Blog Lập Trình Mạng</description>
    <generator>Hugo</generator>
    <language>vi-vn</language>
    <lastBuildDate>Mon, 23 Dec 2024 09:00:00 +0700</lastBuildDate>
    <atom:link href="https://TrungNguyenZzZ.github.io/Blog_Myself/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Buổi 8 (23/12) – Multicast UDP &amp; Java RMI</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-8-multicast-udp-va-java-rmi/</link>
      <pubDate>Mon, 23 Dec 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-8-multicast-udp-va-java-rmi/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Gửi thông báo tới nhiều client cùng nhóm multicast.&lt;/li&gt;&#xA;&lt;li&gt;Hiểu kiến trúc Java RMI và cách tạo interface dịch vụ.&lt;/li&gt;&#xA;&lt;li&gt;Tổng hợp toàn bộ kiến thức để chuẩn bị báo cáo cuối kỳ.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;MulticastSocket&lt;/code&gt; và quy trình join/leave group.&lt;/li&gt;&#xA;&lt;li&gt;Yêu cầu firewall khi dùng địa chỉ 224.0.0.0/4.&lt;/li&gt;&#xA;&lt;li&gt;Component của RMI: interface, implementation, registry, client.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Multicast phù hợp cho các thông báo không yêu cầu xác nhận từng client, ví dụ cập nhật trạng thái lớp học. Ngược lại, RMI giúp gọi hàm từ xa nhưng cần registry hoạt động ổn định. Trong báo cáo mình vẽ sơ đồ tổng hợp: client nhận thông báo multicast, đồng thời có thể gọi RMI để lấy danh sách bài lab.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 7 (16/12) – Đa tuyến và xử lý đồng thời</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-7-da-tuyen-va-xu-ly-dong-thoi/</link>
      <pubDate>Mon, 16 Dec 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-7-da-tuyen-va-xu-ly-dong-thoi/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Biết lựa chọn mô hình thread phù hợp (per-connection, thread-pool).&lt;/li&gt;&#xA;&lt;li&gt;Ngăn chặn race condition khi chia sẻ tài nguyên chung.&lt;/li&gt;&#xA;&lt;li&gt;Ghi nhận số lượng client đang kết nối theo thời gian thực.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;ExecutorService&lt;/code&gt; và pattern submit task cho từng client.&lt;/li&gt;&#xA;&lt;li&gt;Sử dụng &lt;code&gt;ConcurrentHashMap&lt;/code&gt; để lưu trạng thái kết nối.&lt;/li&gt;&#xA;&lt;li&gt;Kết hợp synchronized/lock để bảo vệ tài nguyên quan trọng.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Mình refactor bài TCP trước đó để tận dụng &lt;code&gt;Executors.newFixedThreadPool(8)&lt;/code&gt;. Nhờ vậy server không tạo quá nhiều thread dẫn đến cạn kiệt tài nguyên. Ngoài ra, mình thêm bộ đếm &lt;code&gt;AtomicInteger&lt;/code&gt; để biết hiện có bao nhiêu client online. Báo cáo cũng so sánh thời gian phản hồi giữa mô hình tuần tự và thread-pool.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 6 (09/12) – Lập trình socket UDP</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-6-lap-trinh-socket-udp/</link>
      <pubDate>Mon, 09 Dec 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-6-lap-trinh-socket-udp/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Tạo UDP server và client trao đổi datagram ngắn.&lt;/li&gt;&#xA;&lt;li&gt;Thiết lập timeout để không bị treo khi mất gói.&lt;/li&gt;&#xA;&lt;li&gt;Cài đặt cơ chế ACK đơn giản để đảm bảo nhận đủ thông điệp quan trọng.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;DatagramSocket&lt;/code&gt;, &lt;code&gt;DatagramPacket&lt;/code&gt; và cách tái sử dụng buffer.&lt;/li&gt;&#xA;&lt;li&gt;Chiến lược đặt kích thước gói và xử lý phân mảnh.&lt;/li&gt;&#xA;&lt;li&gt;Cơ chế định thời (timeout) và gửi lại khi không nhận được phản hồi.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Điểm khó nhất là không có kết nối cố định, nên mình phải tự quản lý trạng thái client thông qua địa chỉ/port gửi lên. Ngoài ra, việc đặt kích thước buffer hợp lý giúp tránh lãng phí băng thông. Trong báo cáo mình trình bày bảng thống kê tỷ lệ mất gói khi thử nghiệm với mạng Wi-Fi và cách tăng cường bằng việc gửi lại tối đa 3 lần.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 5 (02/12) – Lập trình sockets TCP</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-5-lap-trinh-socket-tcp/</link>
      <pubDate>Mon, 02 Dec 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-5-lap-trinh-socket-tcp/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Viết server TCP có khả năng phục vụ nhiều client tuần tự.&lt;/li&gt;&#xA;&lt;li&gt;Thiết kế giao thức dạng text gồm phần header và payload.&lt;/li&gt;&#xA;&lt;li&gt;Biết cách log kết nối để dễ debug.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Quy trình &lt;code&gt;ServerSocket.accept()&lt;/code&gt; và &lt;code&gt;Socket&lt;/code&gt; ở phía client.&lt;/li&gt;&#xA;&lt;li&gt;Phương pháp đóng kết nối an toàn sau khi hoàn thành phiên làm việc.&lt;/li&gt;&#xA;&lt;li&gt;Chiến lược xử lý nhiều client: tuần tự, đa luồng, thread pool.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Mình bắt đầu bằng server echo cơ bản sau đó bổ sung lớp xử lý message. Quan trọng nhất là quy ước format: &lt;code&gt;[COMMAND]|[DATA]&lt;/code&gt;. Nhờ format này, server có thể phân tách lệnh &lt;code&gt;PING&lt;/code&gt;, &lt;code&gt;TIME&lt;/code&gt;, &lt;code&gt;QUIT&lt;/code&gt;. Trong báo cáo mình vẽ sơ đồ sequence thể hiện handshake và luồng dữ liệu giữa client-server.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 4 (29/11) – Quản lý địa chỉ kết nối mạng</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-4-quan-ly-dia-chi-ket-noi/</link>
      <pubDate>Fri, 29 Nov 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-4-quan-ly-dia-chi-ket-noi/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Tra cứu IP cục bộ, gateway và card mạng bằng Java.&lt;/li&gt;&#xA;&lt;li&gt;Hiểu cách hệ điều hành lựa chọn cổng nguồn khi mở socket.&lt;/li&gt;&#xA;&lt;li&gt;Nắm quy tắc đặt port cho dịch vụ sinh viên tự triển khai.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Lớp &lt;code&gt;InetAddress&lt;/code&gt;, &lt;code&gt;InetSocketAddress&lt;/code&gt; và &lt;code&gt;NetworkInterface&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Cách bind server vào một địa chỉ cụ thể thay vì 0.0.0.0.&lt;/li&gt;&#xA;&lt;li&gt;Ý nghĩa dải port well-known, registered và dynamic.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Giảng viên yêu cầu mỗi nhóm phải mô tả được server đang lắng nghe ở interface nào và vì sao. Mình thực hành liệt kê toàn bộ adapter và ghi lại trong báo cáo. Nhờ vậy, khi chạy trên máy ảo hoặc lab LAN, mình dễ dàng chỉ định đúng IP để client kết nối. Buổi học cũng nhấn mạnh việc kiểm tra xung đột port khi deploy nhiều dịch vụ.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 3 (25/11) – Quản lý các luồng nhập xuất</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-3-quan-ly-luong-nhap-xuat/</link>
      <pubDate>Mon, 25 Nov 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-3-quan-ly-luong-nhap-xuat/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Phân biệt stream nhị phân và stream ký tự trên Java.&lt;/li&gt;&#xA;&lt;li&gt;Biết cách bọc buffer để tăng hiệu năng đọc/ghi socket.&lt;/li&gt;&#xA;&lt;li&gt;Viết code đóng tài nguyên chính xác, tránh rò rỉ.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Cặp &lt;code&gt;InputStream&lt;/code&gt;/&lt;code&gt;OutputStream&lt;/code&gt; kết hợp với &lt;code&gt;BufferedInputStream&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Cách sử dụng &lt;code&gt;try-with-resources&lt;/code&gt; để tự động đóng socket và stream.&lt;/li&gt;&#xA;&lt;li&gt;Tại sao cần chuẩn hóa định dạng thông điệp (length-prefix, newline&amp;hellip;).&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Buổi này mình nhận ra thao tác IO ảnh hưởng trực tiếp đến độ ổn định của server. Nếu đọc từng byte mà không buffer, CPU sẽ bị kéo xuống đáng kể. Khi viết báo cáo, mình so sánh hai biểu đồ đo thời gian truyền dữ liệu có/không buffer để thấy rõ sự chênh lệch. Ngoài ra, giảng viên nhấn mạnh việc kiểm soát encoding khi chuyển qua stream ký tự để tránh lỗi phân mảnh gói tin.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 2 (18/11) – Kiến thức nền tảng</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-2-kien-thuc-nen-tang/</link>
      <pubDate>Mon, 18 Nov 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-2-kien-thuc-nen-tang/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Ghi nhớ mối liên hệ giữa OSI 7 lớp và TCP/IP.&lt;/li&gt;&#xA;&lt;li&gt;Nhận biết khi nào nên chọn TCP hay UDP.&lt;/li&gt;&#xA;&lt;li&gt;Hiểu cấu trúc cơ bản của Socket API trong Java.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Layer Transport và nhiệm vụ đảm bảo tin cậy/không tin cậy.&lt;/li&gt;&#xA;&lt;li&gt;Định dạng tiêu đề TCP/UDP, ý nghĩa từng trường.&lt;/li&gt;&#xA;&lt;li&gt;Luồng xử lý khi gọi &lt;code&gt;new Socket()&lt;/code&gt; và &lt;code&gt;new ServerSocket()&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Giảng viên yêu cầu trình bày lại quá trình handshake của TCP và cách UDP gửi datagram độc lập. Mình rút ra rằng socket chỉ là điểm cuối của kết nối, còn logic truyền thông phụ thuộc vào cách đóng gói dữ liệu. Khi viết báo cáo, mình so sánh ưu/nhược từng giao thức và minh họa bằng trường hợp sử dụng thực tế như truyền file (TCP) hay gửi thông báo nhanh (UDP).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Buổi 1 (11/11) – Tổng quan khóa học</title>
      <link>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-1-tong-quan-khoa-hoc/</link>
      <pubDate>Mon, 11 Nov 2024 09:00:00 +0700</pubDate>
      <guid>https://TrungNguyenZzZ.github.io/Blog_Myself/blog/buoi-1-tong-quan-khoa-hoc/</guid>
      <description>&lt;h2 id=&#34;mục-tiêu-buổi-học&#34;&gt;Mục tiêu buổi học&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Hiểu kỳ vọng của giảng viên về báo cáo và minh chứng lab.&lt;/li&gt;&#xA;&lt;li&gt;Cài đặt đầy đủ JDK, IDE và công cụ kiểm tra mạng.&lt;/li&gt;&#xA;&lt;li&gt;Phác họa các chủ đề chính sẽ học trong 8 tuần tới.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;kiến-thức-chính&#34;&gt;Kiến thức chính&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Tóm tắt mô hình TCP/IP và vai trò của từng tầng.&lt;/li&gt;&#xA;&lt;li&gt;Lộ trình bài lab: từ Socket cơ bản tới Multicast &amp;amp; RMI.&lt;/li&gt;&#xA;&lt;li&gt;Nguyên tắc viết báo cáo: trình bày lý thuyết, sơ đồ, mã nguồn và kết quả kiểm thử.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;phân-tích--giải-thích&#34;&gt;Phân tích &amp;amp; giải thích&lt;/h2&gt;&#xA;&lt;p&gt;Mình ghi chú lại cách giảng viên đánh giá: mỗi lab cần có mục tiêu, sơ đồ trao đổi gói tin và kiểm chứng kết quả bằng hình ảnh/ghi log. Việc nắm rõ tiêu chí ngay từ buổi đầu giúp tiết kiệm thời gian sửa bài. Ngoài ra, buổi này cũng nhấn mạnh mối liên hệ giữa mô hình TCP/IP với Socket API trên Java, vì vậy mình ôn lại từng layer và ví dụ loại ứng dụng phù hợp.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
